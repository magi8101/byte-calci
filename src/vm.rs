//! Virtual Machine - Executes bytecode instructions
//!
//! Stack-based VM that interprets bytecode generated by the compiler.
//! Uses a fixed-size stack for operands and supports all calculator operations.
//! Supports scalar values and arrays for aggregate operations.

use crate::bytecode::{Chunk, OpCode};
use crate::gc::GarbageCollector;
use std::fmt;

const STACK_MAX: usize = 256;

/// Stack value - can be a scalar or an array
#[derive(Debug, Clone)]
pub enum StackValue {
    Scalar(f64),
    Array(Vec<f64>),
}

impl StackValue {
    pub fn as_scalar(&self) -> Result<f64, VmError> {
        match self {
            StackValue::Scalar(v) => Ok(*v),
            StackValue::Array(arr) if arr.len() == 1 => Ok(arr[0]),
            StackValue::Array(_) => Err(VmError::InvalidOperation("Expected scalar, got array".into())),
        }
    }

    pub fn as_array(&self) -> Vec<f64> {
        match self {
            StackValue::Scalar(v) => vec![*v],
            StackValue::Array(arr) => arr.clone(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum VmError {
    StackOverflow,
    StackUnderflow,
    InvalidOpcode(u8),
    DivisionByZero,
    InvalidOperation(String),
    MathError(String),
}

impl fmt::Display for VmError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VmError::StackOverflow => write!(f, "Stack overflow"),
            VmError::StackUnderflow => write!(f, "Stack underflow"),
            VmError::InvalidOpcode(op) => write!(f, "Invalid opcode: 0x{:02X}", op),
            VmError::DivisionByZero => write!(f, "Division by zero"),
            VmError::InvalidOperation(msg) => write!(f, "Invalid operation: {}", msg),
            VmError::MathError(msg) => write!(f, "Math error: {}", msg),
        }
    }
}

/// Execution trace for debugging/display
#[derive(Debug, Clone)]
pub struct ExecutionStep {
    pub ip: usize,
    pub opcode: OpCode,
    pub operand: Option<f64>,
    pub stack_before: Vec<f64>,
    pub stack_after: Vec<f64>,
}

/// Virtual Machine for executing calculator bytecode
pub struct VirtualMachine {
    /// Operand stack - using StackValue to support arrays
    stack: Vec<StackValue>,
    /// Instruction pointer
    ip: usize,
    /// Garbage collector for memory management
    gc: GarbageCollector,
    /// Execution trace for debugging
    trace: Vec<ExecutionStep>,
    /// Whether to record execution trace
    tracing_enabled: bool,
}

impl VirtualMachine {
    pub fn new() -> Self {
        VirtualMachine {
            stack: Vec::with_capacity(STACK_MAX),
            ip: 0,
            gc: GarbageCollector::new(),
            trace: Vec::new(),
            tracing_enabled: false,
        }
    }

    /// Enable execution tracing
    pub fn enable_tracing(&mut self) {
        self.tracing_enabled = true;
    }

    /// Disable execution tracing
    pub fn disable_tracing(&mut self) {
        self.tracing_enabled = false;
    }

    /// Get execution trace
    pub fn trace(&self) -> &[ExecutionStep] {
        &self.trace
    }

    /// Clear execution trace
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    /// Reset VM state
    pub fn reset(&mut self) {
        self.stack.clear();
        self.ip = 0;
        self.trace.clear();
    }

    /// Push value onto stack
    fn push(&mut self, value: StackValue) -> Result<(), VmError> {
        if self.stack.len() >= STACK_MAX {
            return Err(VmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }

    /// Push scalar onto stack
    fn push_scalar(&mut self, value: f64) -> Result<(), VmError> {
        self.push(StackValue::Scalar(value))
    }

    /// Pop value from stack
    fn pop(&mut self) -> Result<StackValue, VmError> {
        self.stack.pop().ok_or(VmError::StackUnderflow)
    }

    /// Pop scalar from stack
    fn pop_scalar(&mut self) -> Result<f64, VmError> {
        self.pop()?.as_scalar()
    }

    /// Peek at top of stack without popping
    fn peek(&self, distance: usize) -> Result<&StackValue, VmError> {
        if distance >= self.stack.len() {
            return Err(VmError::StackUnderflow);
        }
        Ok(&self.stack[self.stack.len() - 1 - distance])
    }

    /// Get current stack as flat f64 slice (for tracing)
    fn current_stack(&self) -> Vec<f64> {
        self.stack.iter().filter_map(|v| v.as_scalar().ok()).collect()
    }

    /// Read byte at current IP and advance
    fn read_byte(&mut self, chunk: &Chunk) -> u8 {
        let byte = chunk.code()[self.ip];
        self.ip += 1;
        byte
    }

    /// Read f64 constant from bytecode
    fn read_constant(&mut self, chunk: &Chunk) -> f64 {
        let value = chunk.read_f64(self.ip);
        self.ip += 8;
        value
    }

    /// Read u64 from bytecode
    fn read_u64(&mut self, chunk: &Chunk) -> u64 {
        let bytes: [u8; 8] = chunk.code()[self.ip..self.ip + 8]
            .try_into()
            .expect("Invalid u64 bytes");
        self.ip += 8;
        u64::from_le_bytes(bytes)
    }

    /// Calculate factorial
    fn factorial(n: f64) -> Result<f64, VmError> {
        if n < 0.0 {
            return Err(VmError::MathError("Factorial of negative number".into()));
        }
        if n > 170.0 {
            return Err(VmError::MathError("Factorial overflow".into()));
        }
        let n_int = n as u64;
        if (n - n_int as f64).abs() > 1e-10 {
            // Use gamma function for non-integers
            Ok(gamma(n + 1.0))
        } else {
            let mut result = 1.0;
            for i in 2..=n_int {
                result *= i as f64;
            }
            Ok(result)
        }
    }

    /// Calculate GCD (Greatest Common Divisor)
    fn gcd(a: f64, b: f64) -> Result<f64, VmError> {
        let mut a = a.abs() as u64;
        let mut b = b.abs() as u64;
        while b != 0 {
            let temp = b;
            b = a % b;
            a = temp;
        }
        Ok(a as f64)
    }

    /// Calculate LCM (Least Common Multiple)
    fn lcm(a: f64, b: f64) -> Result<f64, VmError> {
        let gcd = Self::gcd(a, b)?;
        if gcd == 0.0 {
            return Ok(0.0);
        }
        Ok((a.abs() * b.abs()) / gcd)
    }

    /// Calculate nPr (Permutations)
    fn npr(n: f64, r: f64) -> Result<f64, VmError> {
        if n < 0.0 || r < 0.0 || r > n {
            return Err(VmError::MathError("Invalid nPr arguments".into()));
        }
        let n_fact = Self::factorial(n)?;
        let nr_fact = Self::factorial(n - r)?;
        Ok(n_fact / nr_fact)
    }

    /// Calculate nCr (Combinations)
    fn ncr(n: f64, r: f64) -> Result<f64, VmError> {
        if n < 0.0 || r < 0.0 || r > n {
            return Err(VmError::MathError("Invalid nCr arguments".into()));
        }
        let n_fact = Self::factorial(n)?;
        let r_fact = Self::factorial(r)?;
        let nr_fact = Self::factorial(n - r)?;
        Ok(n_fact / (r_fact * nr_fact))
    }

    /// Execute a chunk of bytecode
    pub fn execute(&mut self, chunk: &Chunk) -> Result<f64, VmError> {
        self.reset();

        while self.ip < chunk.len() {
            let instruction_ip = self.ip;
            let stack_before = if self.tracing_enabled {
                self.current_stack()
            } else {
                Vec::new()
            };

            let byte = self.read_byte(chunk);
            let opcode = OpCode::from_byte(byte).ok_or(VmError::InvalidOpcode(byte))?;

            let operand = if opcode == OpCode::Push {
                Some(self.read_constant(chunk))
            } else {
                None
            };

            match opcode {
                OpCode::Push => {
                    self.push_scalar(operand.unwrap())?;
                }
                OpCode::Pop => {
                    self.pop()?;
                }
                OpCode::Dup => {
                    let value = self.peek(0)?.clone();
                    self.push(value)?;
                }
                OpCode::PushArray => {
                    let count = self.read_u64(chunk) as usize;
                    let mut elements = Vec::with_capacity(count);
                    // Pop elements in reverse order (they were pushed in order)
                    for _ in 0..count {
                        elements.push(self.pop_scalar()?);
                    }
                    elements.reverse();
                    self.push(StackValue::Array(elements))?;
                }
                OpCode::Add => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(a + b)?;
                }
                OpCode::Sub => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(a - b)?;
                }
                OpCode::Mul => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(a * b)?;
                }
                OpCode::Div => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    if b == 0.0 {
                        return Err(VmError::DivisionByZero);
                    }
                    self.push_scalar(a / b)?;
                }
                OpCode::Pow => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.powf(b))?;
                }
                OpCode::Neg => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(-a)?;
                }
                OpCode::Mod => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    if b == 0.0 {
                        return Err(VmError::DivisionByZero);
                    }
                    self.push_scalar(a % b)?;
                }
                OpCode::Factorial => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(Self::factorial(a)?)?;
                }
                OpCode::Sin => {
                    let a = self.pop_scalar()?;
                    // Convert degrees to radians
                    self.push_scalar((a * std::f64::consts::PI / 180.0).sin())?;
                }
                OpCode::Cos => {
                    let a = self.pop_scalar()?;
                    self.push_scalar((a * std::f64::consts::PI / 180.0).cos())?;
                }
                OpCode::Tan => {
                    let a = self.pop_scalar()?;
                    let rad = a * std::f64::consts::PI / 180.0;
                    let result = rad.tan();
                    if !result.is_finite() {
                        return Err(VmError::MathError("tan undefined at this angle".into()));
                    }
                    self.push_scalar(result)?;
                }
                OpCode::Asin => {
                    let a = self.pop_scalar()?;
                    if a < -1.0 || a > 1.0 {
                        return Err(VmError::MathError("asin domain error".into()));
                    }
                    // Return degrees
                    self.push_scalar(a.asin() * 180.0 / std::f64::consts::PI)?;
                }
                OpCode::Acos => {
                    let a = self.pop_scalar()?;
                    if a < -1.0 || a > 1.0 {
                        return Err(VmError::MathError("acos domain error".into()));
                    }
                    self.push_scalar(a.acos() * 180.0 / std::f64::consts::PI)?;
                }
                OpCode::Atan => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.atan() * 180.0 / std::f64::consts::PI)?;
                }
                OpCode::Sinh => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.sinh())?;
                }
                OpCode::Cosh => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.cosh())?;
                }
                OpCode::Tanh => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.tanh())?;
                }
                OpCode::Sqrt => {
                    let a = self.pop_scalar()?;
                    if a < 0.0 {
                        return Err(VmError::MathError("sqrt of negative number".into()));
                    }
                    self.push_scalar(a.sqrt())?;
                }
                OpCode::Cbrt => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.cbrt())?;
                }
                OpCode::Log => {
                    let a = self.pop_scalar()?;
                    if a <= 0.0 {
                        return Err(VmError::MathError("log of non-positive number".into()));
                    }
                    self.push_scalar(a.log10())?;
                }
                OpCode::Log2 => {
                    let a = self.pop_scalar()?;
                    if a <= 0.0 {
                        return Err(VmError::MathError("log2 of non-positive number".into()));
                    }
                    self.push_scalar(a.log2())?;
                }
                OpCode::Ln => {
                    let a = self.pop_scalar()?;
                    if a <= 0.0 {
                        return Err(VmError::MathError("ln of non-positive number".into()));
                    }
                    self.push_scalar(a.ln())?;
                }
                OpCode::Exp => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.exp())?;
                }
                OpCode::Abs => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.abs())?;
                }
                OpCode::Floor => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.floor())?;
                }
                OpCode::Ceil => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.ceil())?;
                }
                OpCode::Round => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.round())?;
                }
                OpCode::Sign => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a.signum())?;
                }
                OpCode::ToRad => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a * std::f64::consts::PI / 180.0)?;
                }
                OpCode::ToDeg => {
                    let a = self.pop_scalar()?;
                    self.push_scalar(a * 180.0 / std::f64::consts::PI)?;
                }
                // Array operations
                OpCode::Sum => {
                    let arr = self.pop()?.as_array();
                    self.push_scalar(arr.iter().sum())?;
                }
                OpCode::Avg => {
                    let arr = self.pop()?.as_array();
                    if arr.is_empty() {
                        return Err(VmError::MathError("Average of empty array".into()));
                    }
                    self.push_scalar(arr.iter().sum::<f64>() / arr.len() as f64)?;
                }
                OpCode::Min => {
                    let arr = self.pop()?.as_array();
                    if arr.is_empty() {
                        return Err(VmError::MathError("Min of empty array".into()));
                    }
                    self.push_scalar(arr.iter().cloned().fold(f64::INFINITY, f64::min))?;
                }
                OpCode::Max => {
                    let arr = self.pop()?.as_array();
                    if arr.is_empty() {
                        return Err(VmError::MathError("Max of empty array".into()));
                    }
                    self.push_scalar(arr.iter().cloned().fold(f64::NEG_INFINITY, f64::max))?;
                }
                OpCode::Len => {
                    let arr = self.pop()?.as_array();
                    self.push_scalar(arr.len() as f64)?;
                }
                // Binary functions
                OpCode::Gcd => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(Self::gcd(a, b)?)?;
                }
                OpCode::Lcm => {
                    let b = self.pop_scalar()?;
                    let a = self.pop_scalar()?;
                    self.push_scalar(Self::lcm(a, b)?)?;
                }
                OpCode::Npr => {
                    let r = self.pop_scalar()?;
                    let n = self.pop_scalar()?;
                    self.push_scalar(Self::npr(n, r)?)?;
                }
                OpCode::Ncr => {
                    let r = self.pop_scalar()?;
                    let n = self.pop_scalar()?;
                    self.push_scalar(Self::ncr(n, r)?)?;
                }
                OpCode::Halt => {
                    if self.tracing_enabled {
                        self.trace.push(ExecutionStep {
                            ip: instruction_ip,
                            opcode,
                            operand: None,
                            stack_before,
                            stack_after: self.current_stack(),
                        });
                    }
                    break;
                }
            }

            if self.tracing_enabled {
                self.trace.push(ExecutionStep {
                    ip: instruction_ip,
                    opcode,
                    operand,
                    stack_before,
                    stack_after: self.current_stack(),
                });
            }
        }

        // Check if GC should run
        if self.gc.should_collect() {
            self.gc.collect();
        }

        // Return top of stack as result
        if self.stack.is_empty() {
            Ok(0.0)
        } else {
            self.stack.last().unwrap().as_scalar()
        }
    }

    /// Get GC statistics
    pub fn gc_stats(&self) -> &crate::gc::GcStats {
        self.gc.stats()
    }

    /// Get memory statistics
    pub fn memory_stats(&self) -> &crate::memory::MemoryStats {
        self.gc.memory_stats()
    }
}

impl Default for VirtualMachine {
    fn default() -> Self {
        Self::new()
    }
}

/// Gamma function approximation using Lanczos approximation
fn gamma(x: f64) -> f64 {
    // Lanczos approximation constants
    let g = 7;
    let coefficients = [
        0.99999999999980993,
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7,
    ];

    if x < 0.5 {
        // Reflection formula
        std::f64::consts::PI / ((std::f64::consts::PI * x).sin() * gamma(1.0 - x))
    } else {
        let x = x - 1.0;
        let mut a = coefficients[0];
        for i in 1..g + 2 {
            a += coefficients[i] / (x + i as f64);
        }
        let t = x + g as f64 + 0.5;
        (2.0 * std::f64::consts::PI).sqrt() * t.powf(x + 0.5) * (-t).exp() * a
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::CodeGenerator;
    use crate::parser::Parser;
    use crate::tokenizer::Tokenizer;

    fn evaluate(input: &str) -> Result<f64, VmError> {
        let mut tokenizer = Tokenizer::new(input);
        let tokens = tokenizer.tokenize().expect("Tokenization failed");
        let mut parser = Parser::new(tokens);
        let ast = parser.parse().expect("Parsing failed");
        let chunk = CodeGenerator::new().compile(&ast);
        let mut vm = VirtualMachine::new();
        vm.execute(&chunk)
    }

    #[test]
    fn test_simple_addition() {
        let result = evaluate("1 + 2").unwrap();
        assert!((result - 3.0).abs() < 1e-10);
    }

    #[test]
    fn test_complex_expression() {
        let result = evaluate("sin(90) + 2^3").unwrap();
        assert!((result - 9.0).abs() < 1e-10);
    }

    #[test]
    fn test_nested_expression() {
        let result = evaluate("(1 + 2) * (3 + 4)").unwrap();
        assert!((result - 21.0).abs() < 1e-10);
    }

    #[test]
    fn test_power() {
        let result = evaluate("2^3^2").unwrap();
        // 2^(3^2) = 2^9 = 512 (right associative)
        assert!((result - 512.0).abs() < 1e-10);
    }

    #[test]
    fn test_division_by_zero() {
        let result = evaluate("1 / 0");
        assert!(matches!(result, Err(VmError::DivisionByZero)));
    }

    #[test]
    fn test_factorial() {
        let result = evaluate("5!").unwrap();
        assert!((result - 120.0).abs() < 1e-10);
    }

    #[test]
    fn test_modulo() {
        let result = evaluate("10 % 3").unwrap();
        assert!((result - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_gcd() {
        let result = evaluate("gcd(12, 8)").unwrap();
        assert!((result - 4.0).abs() < 1e-10);
    }

    #[test]
    fn test_lcm() {
        let result = evaluate("lcm(4, 6)").unwrap();
        assert!((result - 12.0).abs() < 1e-10);
    }

    #[test]
    fn test_ncr() {
        let result = evaluate("nCr(5, 2)").unwrap();
        assert!((result - 10.0).abs() < 1e-10);
    }

    #[test]
    fn test_npr() {
        let result = evaluate("nPr(5, 2)").unwrap();
        assert!((result - 20.0).abs() < 1e-10);
    }

    #[test]
    fn test_array_sum() {
        let result = evaluate("sum([1, 2, 3, 4])").unwrap();
        assert!((result - 10.0).abs() < 1e-10);
    }

    #[test]
    fn test_array_avg() {
        let result = evaluate("avg([1, 2, 3, 4])").unwrap();
        assert!((result - 2.5).abs() < 1e-10);
    }

    #[test]
    fn test_array_min_max() {
        let min = evaluate("min([3, 1, 4, 1, 5])").unwrap();
        let max = evaluate("max([3, 1, 4, 1, 5])").unwrap();
        assert!((min - 1.0).abs() < 1e-10);
        assert!((max - 5.0).abs() < 1e-10);
    }

    #[test]
    fn test_hyperbolic() {
        let sinh_result = evaluate("sinh(0)").unwrap();
        let cosh_result = evaluate("cosh(0)").unwrap();
        assert!((sinh_result - 0.0).abs() < 1e-10);
        assert!((cosh_result - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_cbrt() {
        let result = evaluate("cbrt(27)").unwrap();
        assert!((result - 3.0).abs() < 1e-10);
    }

    #[test]
    fn test_exp() {
        let result = evaluate("exp(0)").unwrap();
        assert!((result - 1.0).abs() < 1e-10);
    }
}
